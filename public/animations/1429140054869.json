{"name":"Kaleidoscope","filename":"1429140054869.js","author":"Ben","code":"// Ported from Stefan Gustavson's java implementation\r\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\r\n// Read Stefan's excellent paper for details on how this code works.\r\n//\r\n// Sean McCullough banksean@gmail.com\r\n \r\n/**\r\n * You can pass in a random number generator object if you like.\r\n * It is assumed to have a random() method.\r\n */\r\nvar SimplexNoise = function(r) {\r\n\tif (r == undefined) r = Math;\r\n  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], \r\n                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], \r\n                                 [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; \r\n  this.p = [];\r\n  for (var i=0; i<256; i++) {\r\n\t  this.p[i] = Math.floor(r.random()*256);\r\n  }\r\n  // To remove the need for index wrapping, double the permutation table length \r\n  this.perm = []; \r\n  for(var i=0; i<512; i++) {\r\n\t\tthis.perm[i]=this.p[i & 255];\r\n\t} \r\n \r\n  // A lookup table to traverse the simplex around a given point in 4D. \r\n  // Details can be found where this table is used, in the 4D noise method. \r\n  this.simplex = [ \r\n    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0], \r\n    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0], \r\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0], \r\n    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0], \r\n    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0], \r\n    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0], \r\n    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0], \r\n    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]; \r\n};\r\n \r\nSimplexNoise.prototype.dot = function(g, x, y) { \r\n\treturn g[0]*x + g[1]*y;\r\n};\r\n \r\nSimplexNoise.prototype.noise = function(xin, yin) { \r\n  var n0, n1, n2; // Noise contributions from the three corners \r\n  // Skew the input space to determine which simplex cell we're in \r\n  var F2 = 0.5*(Math.sqrt(3.0)-1.0); \r\n  var s = (xin+yin)*F2; // Hairy factor for 2D \r\n  var i = Math.floor(xin+s); \r\n  var j = Math.floor(yin+s); \r\n  var G2 = (3.0-Math.sqrt(3.0))/6.0; \r\n  var t = (i+j)*G2; \r\n  var X0 = i-t; // Unskew the cell origin back to (x,y) space \r\n  var Y0 = j-t; \r\n  var x0 = xin-X0; // The x,y distances from the cell origin \r\n  var y0 = yin-Y0; \r\n  // For the 2D case, the simplex shape is an equilateral triangle. \r\n  // Determine which simplex we are in. \r\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords \r\n  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1) \r\n  else {i1=0; j1=1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1) \r\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and \r\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where \r\n  // c = (3-sqrt(3))/6 \r\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords \r\n  var y1 = y0 - j1 + G2; \r\n  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords \r\n  var y2 = y0 - 1.0 + 2.0 * G2; \r\n  // Work out the hashed gradient indices of the three simplex corners \r\n  var ii = i & 255; \r\n  var jj = j & 255; \r\n  var gi0 = this.perm[ii+this.perm[jj]] % 12; \r\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; \r\n  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12; \r\n  // Calculate the contribution from the three corners \r\n  var t0 = 0.5 - x0*x0-y0*y0; \r\n  if(t0<0) n0 = 0.0; \r\n  else { \r\n    t0 *= t0; \r\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient \r\n  } \r\n  var t1 = 0.5 - x1*x1-y1*y1; \r\n  if(t1<0) n1 = 0.0; \r\n  else { \r\n    t1 *= t1; \r\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); \r\n  }\r\n  var t2 = 0.5 - x2*x2-y2*y2; \r\n  if(t2<0) n2 = 0.0; \r\n  else { \r\n    t2 *= t2; \r\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); \r\n  } \r\n  // Add contributions from each corner to get the final noise value. \r\n  // The result is scaled to return values in the interval [-1,1]. \r\n  return 70.0 * (n0 + n1 + n2); \r\n};\r\n \r\n// 3D simplex noise \r\nSimplexNoise.prototype.noise3d = function(xin, yin, zin) { \r\n  var n0, n1, n2, n3; // Noise contributions from the four corners \r\n  // Skew the input space to determine which simplex cell we're in \r\n  var F3 = 1.0/3.0; \r\n  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D \r\n  var i = Math.floor(xin+s); \r\n  var j = Math.floor(yin+s); \r\n  var k = Math.floor(zin+s); \r\n  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too \r\n  var t = (i+j+k)*G3; \r\n  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space \r\n  var Y0 = j-t; \r\n  var Z0 = k-t; \r\n  var x0 = xin-X0; // The x,y,z distances from the cell origin \r\n  var y0 = yin-Y0; \r\n  var z0 = zin-Z0; \r\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \r\n  // Determine which simplex we are in. \r\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \r\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \r\n  if(x0>=y0) { \r\n    if(y0>=z0) \r\n      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order \r\n      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order \r\n      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order \r\n    } \r\n  else { // x0<y0 \r\n    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order \r\n    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order \r\n    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order \r\n  } \r\n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \r\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \r\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \r\n  // c = 1/6.\r\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \r\n  var y1 = y0 - j1 + G3; \r\n  var z1 = z0 - k1 + G3; \r\n  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords \r\n  var y2 = y0 - j2 + 2.0*G3; \r\n  var z2 = z0 - k2 + 2.0*G3; \r\n  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords \r\n  var y3 = y0 - 1.0 + 3.0*G3; \r\n  var z3 = z0 - 1.0 + 3.0*G3; \r\n  // Work out the hashed gradient indices of the four simplex corners \r\n  var ii = i & 255; \r\n  var jj = j & 255; \r\n  var kk = k & 255; \r\n  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12; \r\n  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12; \r\n  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12; \r\n  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12; \r\n  // Calculate the contribution from the four corners \r\n  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0; \r\n  if(t0<0) n0 = 0.0; \r\n  else { \r\n    t0 *= t0; \r\n    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0); \r\n  }\r\n  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1; \r\n  if(t1<0) n1 = 0.0; \r\n  else { \r\n    t1 *= t1; \r\n    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1); \r\n  } \r\n  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2; \r\n  if(t2<0) n2 = 0.0; \r\n  else { \r\n    t2 *= t2; \r\n    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2); \r\n  } \r\n  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3; \r\n  if(t3<0) n3 = 0.0; \r\n  else { \r\n    t3 *= t3; \r\n    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3); \r\n  } \r\n  // Add contributions from each corner to get the final noise value. \r\n  // The result is scaled to stay just inside [-1,1] \r\n  return 32.0*(n0 + n1 + n2 + n3); \r\n};\r\n\r\n// example code, renders a basic rainbow\r\nvar tv = {\r\n\toffsetX: 0,\r\n\toffsetY: 0\r\n};\r\n\r\nfunction XY(x,y,display) {\r\n    if (y >= display.rows) {\r\n        y = display.rows-1;\r\n    }\r\n    if (x >= display.cols) {\r\n        x = display.cols - 1;\r\n    }\r\n    return y*display.cols + x;\r\n}\r\nreturn {\r\n    generateNoise: function(width, height,scale) {\r\n        var noiser = new SimplexNoise();\r\n        this.noise = [];\r\n        for (var y = 0; y < height; y++) {\r\n            this.noise[y] = [];\r\n            for (var x = 0; x < width; x++) {\r\n                this.noise[y][x] = noiser.noise(x/scale,y/scale);\r\n            }\r\n        }\r\n    },\r\n    getDuration: function(current, newVal, minduration, maxduration) {\r\n      var distance = Math.abs(newVal - current);\r\n      var speed = 0.008;\r\n      var duration = distance / speed;\r\n      /*duration = Math.min(maxduration, duration);\r\n      duration = Math.max(minduration, duration);*/\r\n      return Math.round(duration);\r\n    },\r\n\tinit: function(display,timeline) {\r\n\t\tthis.display = display;\r\n\t\tvar that = this;\r\n   // debugger;\r\n        display.randomizePalettes();\r\n        this.palette = display.getRandomPalette();\r\n        this.generateNoise(display.cols*10, display.rows*10,20);\r\n        \r\n        var targetT1 = Math.random() * (display.cols*9);\r\n        var durationT1 = this.getDuration(tv.offsetX, targetT1, 8000, 10000);\r\n        \r\n      \tvar t1 = display.tween(tv,{\r\n          to: {offsetX: targetT1},\r\n          duration: durationT1,\r\n          repeat: Infinity,\r\n          yoyo: true,\r\n          delay: 300,\r\n          easing: TWEEN.Easing.Linear.None\r\n        });\r\n        t1.onRepeat(function() {\r\n            var targetT1 = Math.random() * (display.cols*9);\r\n            var durationT1 = that.getDuration(tv.offsetX, targetT1, 8000, 10000);\r\n            t1.to({ offsetX: targetT1 },durationT1);\r\n        });\r\n        \r\n        var targetT2 = Math.random() * (display.rows*9);\r\n        var durationT2 = this.getDuration(tv.offsetY, targetT2, 8000, 10000);\r\n        \r\n      \tvar t2 = display.tween(tv,{\r\n          to: {offsetY: targetT2},\r\n          duration: durationT2,\r\n          repeat: Infinity,\r\n          yoyo: true,\r\n          delay: 300,\r\n          easing: TWEEN.Easing.Linear.None\r\n        });\r\n        t2.onRepeat(function() {\r\n            var targetT2 = Math.random() * (display.rows*9);\r\n            var durationT2 = that.getDuration(tv.offsetY, targetT2, 8000, 10000);\r\n            t2.to({ offsetY: targetT2 },durationT2);\r\n        });\r\n\t},\r\n\tonUpdate: function(display, data) {\r\n\t\tvar c = null;\r\n\r\n        for (var x=0; x <= display.cols/2; x++) {\r\n            for (var y=0; y <= display.rows/2; y++) {\r\n                var index = y * display.cols + x;\r\n                \r\n                var noiseLow = this.noise[y+Math.floor(tv.offsetY)][x+Math.floor(tv.offsetX)],\r\n                    noiseHigh = this.noise[y+Math.ceil(tv.offsetY)][x+Math.ceil(tv.offsetX)];\r\n                    \r\n                var value = (noiseLow + noiseHigh)/2;\r\n                c = display.getPaletteColor(this.palette, value+1 ,true);\r\n\t\t\t    display.setColor(index, c);\r\n\t\t\t    // mirror in x and in y\r\n\t\t\t    var tmpY = display.rows - y,\r\n\t\t\t        tmpX = x;\r\n                index = tmpY * display.cols + tmpX;\r\n                display.setColor(index, c);\r\n                \r\n\t\t\t    tmpX = display.cols - x;\r\n                index = tmpY * display.cols + tmpX;\r\n                display.setColor(index, c);\r\n                \r\n\t\t\t    tmpY = y;\r\n                index = tmpY * display.cols + tmpX;\r\n                display.setColor(index, c);\r\n            }\r\n        }\r\n        \r\n\t}\r\n};","publish":true,"script":{}}